# Client와 Sever란 무엇인가?

### 클라이언트 (컴퓨팅)

[컴퓨터 네트워크]에서 **클라이언트**(client, [문화어]는 [네트워크]를 통하여 
[서버]라는 다른 [컴퓨터 시스템]상의 원격 서비스에 접속할 수 있는 [응용 프로그램]이나 서비스를 말한다.
[[1]]구체적으로 말하면 [클라이언트-서버]구조에서 [서버]에서 그 서버가 제공하는 서비스를 요청하고, 
또는 서비스 요청을 위해 필요 인자를 서버가 원하는 방식에 맞게 제공하며, 
서버로부터 반환되는 응답에 사용자에게 적절한 방식으로 표현하는 기능을 가진 프로그램이나 시스템이다.

[https://ko.wikipedia.org/wiki/클라이언트_(컴퓨팅)]

### 서버

**서버** server, [문화어]는 [클라이언트]에게 [네트워크]를 통해 
[정보]나 서비스를 제공하는 [컴퓨터 시스템]으로 **컴퓨터 프로그램**(server program) 
또는 **장치**(device)를 의미한다. 특히, 서버에서 동작하는 [소프트웨어]를 **서버 소프트웨어**(server software)라 한다. 
주로 [리눅스] 등의 [운영 체제]를 설치한 대형 컴퓨터를 쓰지만, 그렇지 않은 경우도 있다.

서버는 프린터 제어나 파일 관리 등 네트워크 전체를 감시·제어하거나, 
[메인프레임]이나 공중망을 통한 다른 네트워크과의 연결, 
데이터·프로그램·파일 같은 소프트웨어 자원이나 모뎀·팩스·프린터 공유, 
기타 장비 등 하드웨어 자원을 공유할 수 있도록 도와주는 역할을 한다.

[https://ko.wikipedia.org/wiki/서버](https://ko.wikipedia.org/wiki/%EC%84%9C%EB%B2%84)

### **클라이언트 / 서버 통신방식의 발전 과정**

[https://t1.daumcdn.net/cfile/tistory/990600385C807E1F11](https://t1.daumcdn.net/cfile/tistory/990600385C807E1F11)

위 그림은 각 시기별 서버/클라이언트 기술을 중심적인 기술을 정리한 것입니다. 

대부분의 소프트웨어 기술은 예전에 나온것은 도태되고 신규로 나오는것을 위주로 계속해서 발전해 나아가지만 
가장 먼저 나온 메인프레임이 아직도 많이 쓰이고 있습니다. 
위 그림에서 말하는 시스템의 변천사는 방식의 차이일 뿐이지 기존에 있던 방법이 나쁘다는것은 아닙니다. 
오히려 예전에 나온 시스템이 새로이 나온 시스템보다 안정성면에서 입증되었기에 더 선호하는 측면도 있는것 같습니다. 
현재는 메인프레임에서도 HTTP와 4GL 언어들을 사용하거나 Client/Server 시스템에서도 HTTP를 통신 프로토콜로 사용하는 등 
기술과 환경들이 상호 교체하며 사용되는 Crossover가 이루어지고 있습니다. 
국내에서는 RIA의 현재 흐름은 대부분 ActiveX를 이용한 방식을 취하고 있는데 
이것은 RIA는 좀더 웹접근성이 보장된 방식을 통하지 않고는 결국 일부에서만 
사용하는 폐쇄된 시스템이 될 것이면 결국 소멸될 가능성이 높습니다.

### **네트워킹 클라이언트 / 서버 시스템 구조**

[https://t1.daumcdn.net/cfile/tistory/996EC5415C80833114](https://t1.daumcdn.net/cfile/tistory/996EC5415C80833114)

일반적으로 클라이언트와 서버시스템 구조는 클라이언트와 서버에서 각각 소켓을 만들어 연결한 뒤  
클라이언트와 서버측에서 요청한 메시지를 상호간에 전송하고 받음으로써 요청한 작업을 수행합니다.

## **WEB 클라이언트 / 서버 통신 구조**

[https://t1.daumcdn.net/cfile/tistory/9946B03E5C80849217](https://t1.daumcdn.net/cfile/tistory/9946B03E5C80849217)

일반적으로 클라이언트는 인터넷에 접속할 수 있는 디바이스를 말하며 대부분의 서버는 웹으로 이루어져 있습니다. 
어디서든 접속이 가능한 인터넷이라는 매체 특성상 이보다 더 좋은 접근성을 가진 매체는 없기 때문입니다. 
웹으로 만들어진 서버와 클라이언트는 일반적으로 브라우저를 통해 통신을 하는데 
다른 Application Layer(응용 계층)의 프로토콜과 마찬가지로 내부적으로 소켓 통신을 사용합니다. 
(웹 HTTP는 TCP/IP 프로토콜 기반이며, Application Layer(응용 계층)에 위치한 프로토콜입니다.) 
그렇기 때문에 기본적으로 Internet Layer(인터넷 계층)의 IP에 접근할 수 있어야 합니다. 
그래서 웹은 DNS 서버를 통해 도메인 주소에서 IP 주소를 얻어옵니다. 이 과정은 위의 그림에서 설명하고 있습니다. 
웹 서버 작동과 클라이언트 호출 과정은 C/S 모델에서의 소켓 통신과 비슷합니다. 
단, C/S 모델에서 사용하는 데이터 전문(패킷) 대신 HTTP 프로토콜에서 정의한 전문과 헤더를 통해 통신을 처리합니다.

[https://coding-factory.tistory.com/329](https://coding-factory.tistory.com/329)

### DNS란 무엇입니까?

도메인 이름 시스템(DNS)은 사람이 읽을 수 있는 도메인 이름(예: www.amazon.com)을 머신이 읽을 수 있는 IP 주소(예: 192.0.2.44)로 변환합니다.

### DNS 기본 사항

스마트폰이나 노트북부터 대규모 소매 웹 사이트의 콘텐츠를 서비스하는 서버에 이르기까지 
인터넷상의 모든 컴퓨터는 숫자를 사용하여 서로를 찾고 통신합니다. 이러한 숫자를 **IP 주소**라고 합니다. 
웹 브라우저를 열고 웹 사이트로 이동할 때는 긴 숫자를 기억해 입력할 필요가 없습니다. 
그 대신 example.com과 같은 **도메인 이름**을 입력해도 원하는 웹 사이트로 갈 수 있습니다.

Amazon Route 53과 같은 DNS 서비스는 전 세계에 배포된 서비스로서, 
www.example.com과 같이 사람이 읽을 수 있는 이름을 192.0.2.1과 같은 숫자 IP 주소로 변환하여 
컴퓨터가 서로 통신할 수 있도록 합니다. 인터넷의 DNS 시스템은 이름과 숫자 간의 매핑을 관리하여 마치 전화번호부와 같은 기능을 합니다. DNS 서버는 이름을 IP 주소로 변환하여 도메인 이름을 웹 브라우저에 입력할 때 최종 사용자를 어떤 서버에 연결할 것인지를 제어합니다. 
이 요청을 **쿼리**라고 부릅니다.

**DNS 서비스 유형**

**신뢰할 수 있는 DNS:** **신뢰할 수 있는 DNS** 서비스는 개발자가 퍼블릭 DNS 이름을 관리하는 데 
사용하는 업데이트 메커니즘을 제공합니다. 이 메커니즘을 통해 DNS 시스템은 DNS 쿼리에 응답하고 도메인 이름을 IP 주소로 변환합니다. 그러면 컴퓨터가 서로 통신할 수 있게 됩니다. 
신뢰할 수 있는 DNS는 도메인에 대해 최종 권한이 있으며 **재귀적 DNS** 서버에 IP 주소 정보가 담긴 답을 제공할 책임이 있습니다. **Amazon Route 53은 신뢰할 수 있는 DNS 시스템입니다.**

**재귀적 DNS:** 대개 클라이언트는 신뢰할 수 있는 DNS 서비스에 직접 쿼리를 수행하지 않습니다. 
대신에 **해석기** 또는 **재귀적 DNS** 서비스라고 알려진 다른 유형의 DNS 서비스에 연결하는 경우가 일반적입니다. 
재귀적 DNS 서비스는 호텔 컨시어지와 같은 역할을 합니다. 
DNS 레코드를 소유하고 있지 않지만 사용자를 대신해서 DNS 정보를 가져올 수 있는 중간자의 역할을 합니다. 
재귀적 DNS가 일정 기간 **캐시된** 또는 저장된 DNS 참조를 가지고 있는 경우, 
소스 또는 IP 정보를 제공하여 DNS 쿼리에 답을 합니다. 
그렇지 않다면, 해당 정보를 찾기 위해 쿼리를 하나 이상의 신뢰할 수 있는 DNS 서버에 전달합니다.

### DNS는 트래픽을 웹 애플리케이션에 어떻게 라우팅합니까?

다음 다이어그램은 재귀적 DNS 서비스와 신뢰할 수 있는 DNS 서비스가 서로 연계하여 
최종 사용자를 웹 사이트 또는 애플리케이션으로 라우팅하는 방법에 대한 개요를 보여줍니다.

![https://d1.awsstatic.com/Route53/how-route-53-routes-traffic.8d313c7da075c3c7303aaef32e89b5d0b7885e7c.png](https://d1.awsstatic.com/Route53/how-route-53-routes-traffic.8d313c7da075c3c7303aaef32e89b5d0b7885e7c.png)

1. 사용자가 웹 브라우저를 열어 주소 표시줄에 www.example.com을 입력하고 Enter 키를 누릅니다.
2. www.example.com에 대한 요청은 일반적으로 케이블 인터넷 공급업체, 
DSL 광대역 공급업체 또는 기업 네트워크 같은 인터넷 서비스 제공업체(ISP)가 관리하는 DNS 해석기로 라우팅됩니다.
3. ISP의 DNS 해석기는 www.example.com에 대한 요청을 DNS 루트 이름 서버에 전달합니다.
4. ISP의 DNS 해석기는 www.example.com에 대한 요청을 이번에는 .com 도메인의 TLD 이름 서버 중 하나에 다시 전달합니다. 
.com 도메인의 이름 서버는 example.com 도메인과 연관된 4개의 Amazon Route 53 이름 서버의 이름을 사용하여 요청에 응답합니다.
5. ISP의 DNS 해석기는 Amazon Route 53 이름 서버 하나를 선택해 www.example.com에 대한 요청을 해당 이름 서버에 전달합니다.
6. Amazon Route 53 이름 서버는 example.com 호스팅 영역에서 www.example.com 레코드를 찾아 
웹 서버의 IP 주소 192.0.2.44 등 연관된 값을 받고 이 IP 주소를 DNS 해석기로 반환합니다.
7. ISP의 DNS 해석기가 마침내 사용자에게 필요한 IP 주소를 확보하게 됩니다. 
해석기는 이 값을 웹 브라우저로 반환합니다. 
또한, DNS 해석기는 다음에 누군가가 example.com을 탐색할 때 좀 더 빠르게 응답할 수 있도록 사용자가 지정하는 일정 기간 example.com의 IP 주소를 캐싱(저장)합니다. 
자세한 내용은 Time to Live(TTL)를 참조하세요.
8. 웹 브라우저는 DNS 해석기로부터 얻은 IP 주소로 www.example.com에 대한 요청을 전송합니다. 
여기가 콘텐츠가 있는 곳으로, 예를 들어 웹 사이트 엔드포인트로 구성된 Amazon S3 버킷 또는 Amazon EC2 인스턴스에서 실행되는 웹 서버입니다.
9. 192.0.2.44에 있는 웹 서버 또는 그 밖의 리소스는 www.example.com의 웹 페이지를 웹 브라우저로 반환하고, 
웹 브라우저는 이 페이지를 표시합니다.

[https://aws.amazon.com/ko/route53/what-is-dns/](https://aws.amazon.com/ko/route53/what-is-dns/)

### **RIA(Rich Internet Application)**

웹 애플리케이션의 장점은 유지하면서 기존 웹 브라우저 기반 인터페이스의 단점인 늦은 응답 속도, 
데스크톱 애플리케이션에 비해 떨어지는 조작성 등을 개선하기 위한 기술의 통칭입니다. 
즉, 별도의 설치가 필요 없는 웹 브라우저 기반의 애플리케이션 배포 장점과 서버 측 웹 서비스와의 연동, 
마크업 언어 기반의 선언적 애플리케이션 구성 등은 유지하면서 데스크톱 애플리케이션과 대등한 사용자 경험을 주는 것을 목표로 하는 기술입니다. 
흔히 어도비 플래시 기반 플렉스나 마이크로소프트 실버라이트, 자바FX 등 별도의 런타임 시스템을 가진 기술을 지칭하는 용어로 
사용되나 웹 브라우저에서 실행되는 애플리케이션의 사용자 인터페이스를 향상하는 기법인 Ajax, 
사용자 인터페이스 관점에서 많은 발전을 가져올 HTML5 등에 기반한 애플리케이션을 지칭하기도 합니다. 
별도의 런타임 시스템을 가진 기술의 경우 애플리케이션은 브라우저 내에서 플러그인으로 실행되기도 하고 단독으로 실행되는 경우도 있습니다. 이 같이 "RIA"라는 개념은 정확한 정의가 있다기 보다는 다소 모호하고 넓은 의미로 사용되고 있습니다. 
현재의 RIA는 HTML5와 CSS3 등의 표준 웹 방식과 jquery 등의 범용적이고 
표준에 가까운 라이브러리를 이용한 방식이 선호되고 있습니다. 
그동안 대표적인 RIA로 언급되었던 Adobe사의 AIR도 ActiveX와 같이 플러그인이 설치되어야하는 기술이었으며 
결국 Adobe사는 AIR에 대한 전망을 접기로 결정하고 개발과 지원을 하지 않기로 하였으며, 
HTML5에 더 많은 기술 연구에 집중하고 있다는 사실에서도 증명되고 있습니다.

[https://coding-factory.tistory.com/329](https://coding-factory.tistory.com/329)

**HTML5**

**HTML5**는 [HTML]의 완전한 5번째 버전으로 월드 와이드 웹 (World Wide Web)의 핵심 [마크업 언어]이다. 

HTML5는 [HTML 4.01], [XHTML] 1.0, DOM 레벨 2 HTML에 대한 차기 표준 제안이다. 비디오, 오디오 등 다양한 부가기능과 최신 멀티미디어 콘텐츠를 [액티브X] 없이 브라우저에서 쉽게 볼 수 있게 하는 것을 목적으로 한다.

### **HTML4와의 차이점**

- 요소 추가
    - 구조적인 요소 - 구역을 나누는 블록 요소인 div 요소를 대신한다.
        - header
        - nav
        - article
        - section
        - aside
        - footer
    - 멀티미디어 요소 - [플러그인]없이 멀티미디어를 재생할 수 있게 한다.
        - audio - 오디오를 재생한다.
        - video - 비디오를 재생한다.
        - canvas
    - command
    - datalist
    - details
    - embed
    - figure
    - figcaption
- 요소 의미 변경
    - em
    - hr
- 문서 선언 - `<!DOCTYPE html>`으로 간소화 되었다.(대소문자 구별 안함)
- 요소 제거
    - 비슷한 기능의 다른 태그로 대체 가능한 태그들 - acronym, applet, dir, isindex
    - 디자인적인 기능 이상의 의미가 없어 삭제 (CSS로 대체 가능한 태그들) - basefont, big, center, font, strike, tt
    - 웹 접근성 향상을 위해 사용을 지양하는 태그들 - frame, frameset, noframes

[https://ko.wikipedia.org/wiki/HTML5](https://ko.wikipedia.org/wiki/HTML5)

### **HTML5 로 제작된 사이트 소개**

```
<html>5 gallery
소개: HTML5 로 개발된 사이트를 소개하는 사이트
[URL:http://html5gallery.com/](http://html5gallery.com/)
```

[https://m.mkexdev.net/65](https://m.mkexdev.net/65)